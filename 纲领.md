### **项目：Obsidian课堂纪要自动化系统**

#### **I. 核心理念**

*   **数据锚定**: 以音频文件的精确时间戳为流程起点和唯一可靠标识。
*   **半自动化**: 自动化所有重复性、规则性的工作，将人的精力聚焦在转录校对和内容审阅上。
*   **模板化处理**: 根据课程性质（临床型 vs. 通用型）调用不同的处理模板，实现灵活、高效的内容生成。
*   **知识闭环**: 不仅生成笔记，还通过Anki格式建议，将知识推向记忆和内化的环节。
*   **健壮与可靠**: 详尽的日志、原子化的文件操作、明确的错误回退机制。

---

#### **II. 项目结构与环境**

1.  **文件夹结构**:
    ```
    /audionote-processor/
    |-- main.py                     # 主程序入口
    |-- file_monitor.py             # (独立进程) 音频文件自动重命名
    |
    |-- /modules/
    |   |-- config_manager.py       # 统一管理和加载.env配置
    |   |-- ics_parser.py           # ICS日历解析与课程匹配
    |   |-- llm_handler.py          # LLM API交互（含模板选择）
    |   |-- obsidian_manager.py     # Obsidian文件和目录操作
    |   |-- logger_config.py        # 日志配置
    |   |-- text_utils.py           # 文本处理工具（如繁转简）
    |
    |-- /prompts/
    |   |-- clinical_template.txt   # 临床课程Prompt模板
    |   |-- general_template.txt    # 通用课程Prompt模板
    |
    |-- .env                        # 配置文件
    |-- requirements.txt            # Python依赖包
    |-- your_schedule.ics           # 课程日历文件
    ```

2.  **.env 配置文件**:
    ```ini
    # [PATHS]
    AUDIO_DIR = "/Users/justin/Music/课程录制"
    TRANSCRIPT_DIR = "/Users/justin/Music/课程录制/转录稿"
    PROCESSED_TRANSCRIPT_DIR = "/Users/justin/Music/课程录制/转录稿/已处理"
    OBSIDIAN_VAULT_PATH = "/Users/justin/Library/Mobile Documents/iCloud~md~obsidian/Documents/Cloud Vault"
    ICS_FILE_PATH = "./your_schedule.ics"
    LOG_FILE_PATH = "./processor.log"

    # [SETTINGS]
    ENABLE_AUTO_RENAME = true
    SEMESTER_START_DATE = "2025-09-15"
    CLINICAL_COURSES = "内科护理学I,外科护理学,精神科护理学,妇产科护理学,儿科护理学" # 逗号分隔

    # [LLM]
    LLM_API_BASE = "https://api.openai.com/v1"
    LLM_API_TOKEN = "your_secret_api_key"
    LLM_MODEL_NAME = "gpt-4-turbo-preview"
    LLM_RETRY_COUNT = 3
    LLM_RETRY_DELAY = 5 # seconds
    ```

3.  **requirements.txt**: `python-dotenv`, `ics`, `opencc-python-reimplemented`, `openai`, `watchdog`

---

#### **III. 工作流分解**

##### **工作流 A: 音频文件锚定 (后台独立进程 `file_monitor.py`)**

*   **目标**: 确保所有进入系统的音频都有一个标准的时间戳文件名。
*   **步骤**:
    1.  **启动**: 独立运行 `python file_monitor.py`。
    2.  **监控**: 使用 `watchdog` 监控 `AUDIO_DIR` 的文件创建事件。
    3.  **处理**:
        *   当新音频文件被创建，检查其文件名。
        *   若文件名**不**以 `YYYYMMDD-HHMMSS-` 开头：
            *   获取当前时间戳。
            *   将文件重命名为 `{时间戳}-{原文件名}`。
            *   记录日志：`[INFO] Renamed audio file: '{old_name}' -> '{new_name}'`。
    *   **健壮性**: 脚本应能处理并发创建、文件名冲突等边缘情况，并持续运行。

**[-- 用户手动环节: 使用第三方工具转录音频，并将.txt转录稿保存到 `TRANSCRIPT_DIR` --]**

##### **工作流 B: 核心处理流程 (主程序 `main.py`)**

*   **目标**: 将`TRANSCRIPT_DIR`中的`.txt`文件处理成结构化的Obsidian笔记。
*   **步骤**:

    **1. 启动与初始化**
        *   **日志**: 启动 `logger_config`，配置日志格式、级别，输出到控制台和文件。
        *   **配置**: 实例化 `ConfigManager`，加载所有`.env`配置。
        *   **日历**: 实例化 `ICSParser`，传入ICS文件路径，解析并加载所有课程事件数据到内存。
        *   **日志**: `[INFO] System initialized. Found {N} events in calendar.`

    **2. 扫描与任务过滤**
        *   扫描 `TRANSCRIPT_DIR`，获取所有 `.txt` 文件列表。
        *   若列表为空，记录日志后正常退出。
        *   **日志**: `[INFO] Found {N} new transcripts. Starting processing.`

    **3. 单文件处理循环 (核心)**
        *   `for file_path in transcript_files:`
            *   **日志**: `[INFO] >>> Processing: {file_name}`
            *   **a. 上下文构建 (Context Building)**
                *   **时间戳**: 从文件名提取 `YYYYMMDD-HHMMSS`。若失败，用文件创建时间作为备用，并记录`[WARN]`日志。
                *   **课程匹配**: 调用`ICSParser`的匹配方法，传入时间戳，获取课程信息 `{'course_name': '...', 'week_num': ...}`。
                *   **匹配失败处理**: 若返回 `None`，向用户`input()`请求手动输入，若用户跳过，则记录`[ERROR]`并`continue`处理下一个文件。
            *   **b. 文本预处理**
                *   读取`.txt`文件内容。
                *   调用`text_utils.process()`进行繁转简。
            *   **c. LLM智能处理**
                *   调用 `LLMHandler` 的 `generate_note` 方法，传入：
                    *   `transcript_content` (转录稿内容)
                    *   `course_info` (课程信息字典)
                *   `generate_note` 内部逻辑：
                    *   根据 `course_info['course_name']` 是否在 `config.CLINICAL_COURSES` 列表中，决定加载 `clinical_template.txt` 还是 `general_template.txt`。
                    *   **日志**: `[DEBUG] Selected LLM template: '{template_name}'`。
                    *   将模板与传入的数据格式化成最终的Prompt。
                    *   带重试逻辑地调用LLM API。
                    *   若成功，返回LLM生成的完整Markdown字符串；若失败，返回`None`。
            *   **d. LLM失败处理**
                *   如果 `generate_note` 返回 `None`，记录`[FATAL]`日志，说明LLM处理失败，然后`continue`处理下一个文件。此时不移动源文件，以便下次重试。
            *   **e. Obsidian归档 (原子操作)**
                *   实例化 `ObsidianManager`，传入`vault_path`和`course_info`。
                *   **计算序号**: `manager.get_next_sequence_num()`。
                *   **保存转录稿**: `manager.save_transcript(sequence_num, transcript_content)`。
                *   **保存纪要**: `manager.save_note(sequence_num, llm_generated_content)`。
                    *   `save_note`内部实现：先解析`topic`，构造最终文件名，然后先写入`.tmp`文件，成功后再重命名，确保原子性。
                *   **日志**: `[SUCCESS] Transcript and Note for '{course_name}' Week {week} have been saved.`
            *   **f. 源文件归档**
                *   将处理成功的`.txt`文件移动到 `PROCESSED_TRANSCRIPT_DIR`。
                *   **日志**: `[INFO] Archived source file: {file_name}`
            *   **日志**: `[INFO] <<< Finished: {file_name}`

    **4. 流程结束**
        *   **日志**: `[INFO] All tasks completed. Shutting down.`

---

#### **IV. 模块职责明细**

*   **`config_manager.py`**:
    *   `class ConfigManager`: 初始化时加载`.env`，提供一个`get(key)`方法来安全地获取配置值。

*   **`logger_config.py`**:
    *   `def setup_logger()`: 配置`logging`模块，返回一个logger实例。

*   **`ics_parser.py`**:
    *   `class ICSParser`:
        *   `__init__(ics_path, start_date)`: 解析ICS文件，计算每个事件的发生实例。
        *   `match_course(target_datetime)`: 核心匹配逻辑，处理周次、单双周，返回课程信息字典或`None`。

*   **`text_utils.py`**:
    *   `def to_simplified(text)`: 封装繁转简功能。

*   **`llm_handler.py`**:
    *   `class LLMHandler`:
        *   `__init__(config)`: 初始化API客户端和配置。
        *   `generate_note(transcript, course_info)`: 核心方法，实现模板选择、Prompt构建、API调用和重试。

*   **`obsidian_manager.py`**:
    *   `class ObsidianManager`:
        *   `__init__(vault_path, course_info)`: 初始化路径。
        *   `get_next_sequence_num()`: 计算序号。
        *   `save_transcript(...)`: 保存转录稿。
        *   `save_note(...)`: 保存纪要（含原子操作）。
        *   所有方法都应包含路径创建（如果不存在）的逻辑。
